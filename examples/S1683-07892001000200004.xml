<?xml version="1.0" encoding="ISO-8859-1"?><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<front>
<journal-meta>
<journal-id>1683-0789</journal-id>
<journal-title><![CDATA[Acta Nova]]></journal-title>
<abbrev-journal-title><![CDATA[RevActaNova.]]></abbrev-journal-title>
<issn>1683-0789</issn>
<publisher>
<publisher-name><![CDATA[Universidad Católica Boliviana]]></publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id>S1683-07892001000200004</article-id>
<title-group>
<article-title xml:lang="es"><![CDATA[Editor Genérico de Estructuras]]></article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname><![CDATA[Aparicio Yuja]]></surname>
<given-names><![CDATA[Nancy Tatiana]]></given-names>
</name>
</contrib>
</contrib-group>
<aff id="A01">
<institution><![CDATA[,Universidad Católica Boliviana Departamento de Ingeniería de Sistemas ]]></institution>
<addr-line><![CDATA[ ]]></addr-line>
</aff>
<pub-date pub-type="pub">
<day>00</day>
<month>00</month>
<year>2001</year>
</pub-date>
<pub-date pub-type="epub">
<day>00</day>
<month>00</month>
<year>2001</year>
</pub-date>
<volume>1</volume>
<numero>2</numero>
<fpage>161</fpage>
<lpage>180</lpage>
<copyright-statement/>
<copyright-year/>
<self-uri xlink:href="http://www.scielo.org.bo/scielo.php?script=sci_arttext&amp;pid=S1683-07892001000200004&amp;lng=en&amp;nrm=iso"></self-uri><self-uri xlink:href="http://www.scielo.org.bo/scielo.php?script=sci_abstract&amp;pid=S1683-07892001000200004&amp;lng=en&amp;nrm=iso"></self-uri><self-uri xlink:href="http://www.scielo.org.bo/scielo.php?script=sci_pdf&amp;pid=S1683-07892001000200004&amp;lng=en&amp;nrm=iso"></self-uri><abstract abstract-type="short" xml:lang="es"><p><![CDATA[En el presente trabajo se explotan las ventajas de la programación funcional, para construir un editor, que permite la manipulación directa de estructuras libres de contexto con una interfaz gráfica. Como resultado de este trabajo se obtiene un modelo genérico (en el sentido que es muy fácil adaptarlo a estructuras particula­res) y al mismo tiempo sencillo (se identifican claramente un modelo de datos en que cada componente de la estructura guarda "su" estado y un modelo de progra­ma en que las operaciones esenciales de edición están definidas por álgebras que son pasadas a una función fold que trabaja sobre la estructura). El trabajo apunta a la obtención de un programa generador de editores que reciba una gramática libre de contexto y retorne un editor para el lenguaje que obedece a tal gramática.]]></p></abstract>
</article-meta>
</front><body><![CDATA[ <p align=center><font size="4" face="Verdana, Arial, Helvetica, sans-serif"><B>Editor Genérico de Estructuras</B></font></p>      <p align=center>Nancy Tatiana Aparicio Yuja</p>      <p align=center>Departamento de Ingeniería de Sistemas</p>      <p align=center>Universidad Católica Boliviana, Regional Cochabamba</p>      <p align=center>e-mail: <u><a href="mailto:aparicio@ucbcba.edu.bo">aparicio@ucbcba.edu.bo</a></u></p>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>Resumen</B></font></p>      <p>En el presente trabajo se explotan las ventajas de la programación funcional, para construir un editor, que permite la manipulación directa de estructuras libres de contexto con una interfaz gráfica. Como resultado de este trabajo se obtiene un modelo genérico (en el sentido que es muy fácil adaptarlo a estructuras particula­res) y al mismo tiempo sencillo (se identifican claramente un <i>modelo de datos </i>en que cada componente de la estructura guarda &quot;su&quot; estado y un <i>modelo de progra­ma </i>en que las operaciones esenciales de edición están definidas por álgebras que son pasadas a una función fold que trabaja sobre la estructura). El trabajo apunta a la obtención de un programa generador de editores que reciba una gramática libre de contexto y retorne un editor para el lenguaje que obedece a tal gramática.</p>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>1 Introducción</B></font></p>      <p>Cada vez que se diseña un nuevo lenguaje, surge la necesidad de desarrollar la aplicación que permita editar objetos que obedezcan a su estructura; es por ello que resultaría de gran utilidad para los diseñadores de lenguajes, con tan solo la especificación sintáctica del nuevo lenguaje mediante una gramática libre de contexto, generar su editor sin ningún costo. Apuntando a tal aplicación, en el presente artículo se presenta un edi­tor de estructuras de árboles rosa (Arboles con cualquier cantidad de descendientes por nodo) que puede ser fácilmente adaptado a estructuras particulares.</p>      <p>La propuesta se implementa en el lenguaje funcional Haskell porque el paradigma de la programación funcional, con sus poderosas herramientas de abstracción de datos y programas, es ideal para la obtención de aplicaciones generales, lo que es el primer paso para la posterior construcción de aplicaciones genéricas. Algunos argumentos que corroboran lo anterior son los siguientes: <br clear=all> </p>      ]]></body>
<body><![CDATA[<p align="center"><img src="/img/revistas/ran/v1n2/1-Aparicio.JPG" width="713" height="82"></p>      <p><b>Figura 1:</b>   El objeto a editarse tiene tres representaciones:   el objeto estructurado,  la estructura árbol que lo modela y la presentación.</p>      <p>• La especificación de una estructura mediante una gramática libre de contexto tiene su correspondencia directa con un tipo de datos del lenguaje funcional Haskell. Una producción de la gramática <i>p : </i><i>X </i><i>—&gt; Y </i>puede ser interpretada funcionalmente como una definición del tipo <i>X </i>o una función constructora g con tipo <i>g :: Y —&gt; </i><i>X.</i></p>      <p>•Libera al programador de administrar memoria, tarea que distrae su atención en aspectos no esenciales a la solución del problema [3, 9].</p>      <p>•Las estructuras de datos y las funciones son manejadas como valores de primer orden, lo que da mayor libertad para manipular estos elementos de programación. Esta característica permite que una función pueda ser argumento o resultado de otra, lo cual es una herramienta útil para la obtención de funciones generales [3, 9].</p>      <p>•&nbsp;La programación funcional permite evaluación &quot;lazy&quot; para reducir expresiones [3], en virtud a esta característica es posible definir funciones con expresiones que usan valores calculados por las propias expresiones, lo que nos da mayor poder de expresividad al especificar modelos.</p>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>2 Especificación del editor</B></font></p>      <p>En un editor se pueden identificar dos componentes principales: la estructura a editarse y las operaciones para manipularla.</p>      <p><b>2.1 La estructura</b></p>      <p>Se desea obtener un editor que trabaje sobre objetos que obedecen a gramáticas libres de contexto. Todo objeto que obedece a una gramática libre de contexto puede ser modelado como árbol (detrás de una frase que obedece al lenguaje, existe un árbol de derivación). Por tanto, la estructura que está siendo editada, además de tener una representación para ser visualizada en pantalla, puede tener una representación en una estructura general: un árbol. En este contexto, podemos identificar tres tipos de representaciones para una estructura libre de contexto a editarse: la estructura, la estructura modelada como árbol y su presentación en pantalla, como puede observarse en la Figura 1.</p>      ]]></body>
<body><![CDATA[<p>En el presente trabajo nos ocuparemos de la <i>estructura árbol </i>porque al obtener un editor para un árbol se obtiene automáticamente un editor para cualquier objeto que pueda ser modelado como tal.</p>        <p align="center"><img src="/img/revistas/ran/v1n2/2-Aparicio.JPG" width="308" height="262"></p>       <p align="center"> <img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/tablaApa.JPG" width="217" height="197"></p> <br clear=all>     <p align=center><b>Figura 2:</b> Un árbol y su presentación en pantalla.</p>      <p>Aunque es un aspecto particular de la estructura que se edita, se trabajará en la <i>presentación </i>para experimentar con mecanismos de interacción en programación fun­cional (La implementaci&oacute;n de aplicaciones interactivas en programaci&oacute;n funcional se complica por el ma&shy;nejo de estados que implica.) y obtener un producto que permita hacer una manipulación directa del objeto, utilizando el mouse.</p>      <p><b><i>2.1.1 Especificación de la estructura árbol</i></b></p>      <p>Se construirá un editor para un árbol rosa que cumpla las siguientes características:</p>      <p>1. Cada nodo tiene n descendientes que pueden ser direccionados individualmente (n puede variar de nodo a nodo).</p>      <p>2.&nbsp;Solo se guarda información en nodos terminales, los no terminales guardan la estructura.</p>      <p>3.&nbsp;Todos los datos guardados son del mismo tipo.</p>      ]]></body>
<body><![CDATA[<p><b><i>2.1.2 Especificación de la presentación</i></b></p>      <p>Se mostrará el árbol como texto, desplegando cada elemento en una fila diferente y utilizando indentaciones para representar la profundidad del elemento (ver Figura 2).</p>      <p><b>2.2 Las operaciones</b></p>      <p>Se implementarán operaciones de navegación, manipulación y despliegue.</p>      <p><b><i>2.2.1 Operaciones de navegación/selección</i></b></p>      <p>Se hará la navegación mediante el mouse, así el usuario tendrá libertad y facilidad para mover el foco de selección en la estructura. Se considerarán las siguientes características de enfoque:</p>      <p>1. Una selección siempre incluirá hojas (la selección de un nodo no terminal, implica la selección de toda su descendencia).</p>      <p>2. Una selección siempre abarcará un subárbol cada vez.</p>      <p><b><i>2.2.2 Operaciones de manipulación/transformación</i></b></p>      <p>El área seleccionada de la estructura puede ser modificada en contenido (modificar el contenido de una hoja) o en estructura (transformar una hoja en rama, transformar una rama en hoja).</p>      ]]></body>
<body><![CDATA[<p><b><i>2.2.3 Operaciones de despliegue</i></b></p>      <p>Los comandos de despliegue permitirán llevar a cabo las anteriores operaciones (selec­ción y transformación) mediante la manipulación directa de la estructura por el usuario, por lo que las operaciones que se considerarán, entre otras, son las siguientes:</p>      <p>1.  Calcular posiciones de despliegue en pantalla, de cada uno de los componentes del árbol.</p>      <p>2. Desplegar, en posiciones exactas de la pantalla y con un color específico, cada nodo del árbol.</p>      <p>3. Borrar el árbol para poder desplegar las transformaciones realizadas por el usuario.</p>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>3 Modelo de la solución</B></font></p>      <p><b>3.1 Modelo de datos</b></p>      <p>Para implementar las operaciones indicadas, se requiere mantener la siguiente informa­ción de estado: posiciones de despliegue de cada componente del árbol, ubicación de cada componente dentro de la estructura, componentes del árbol seleccionados y valor que guarda cada componente.</p>      <p>Lo más sencillo es guardar esta información en el propio árbol, cada nodo conocerá &quot;su&quot; estado: posición de despliegue, ubicación en la estructura, si está seleccionado o no y el valor que guarda. Para ello se propone el modelo de datos presentado en el Algoritmo 1 e ilustrado en la Figura 3.</p>      <p><b>3.2 Modelo de programa</b></p>      ]]></body>
<body><![CDATA[<p>Para implementar las operaciones del editor se trabajará composicionalmente [4]. Tra­bajar composicionalmente consiste en tomar ventaja de la estructura y hacer que cada<br clear=all> </p> <hr>     <p><b>Algoritmo 1 </b>: Modelo de Datos que corresponde a una definición de tipo en Haskell. Cada nodo del árbol guardará la tupia (posición, valor, marca), que corresponde a (posición en la ventana donde se desplegará el elemento, valor que guarda, valor lógico que indica seleccionado / no seleccionado).</p>      <p>data Arbol  a = Nodo  a   [Arbol  a]</p>      <p>type Estado  =   (Posicion,   String,   Marca)</p>      <p>type Posición =   (Int,Int)</p>      <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/Algo1Apa.JPG" width="710" height="232"><br clear=all>             </p>     <p><b>Figura 3: </b>Un ejemplo de un árbol representado en el modelo de datos y su correspondiente presentación en pantalla. Obsérvese que no es necesario guardar la ubicación de cada componente en la estructura porque está implícita en el árbol.</p> <hr>    <p>uno de los componentes de la misma tenga una tarea asignada, de modo que se haga una composición del trabajo. Para implementar esto, será necesario realizar lo siguiente:</p>      <p>1. Identificar los puntos estructurales del objeto, que se corresponden directamente con los constructores del tipo de datos definido. En el caso específico del modelo de datos usado, se tienen tres puntos estructurales: <i>Nodo, </i>(:),[] (en base a estos elementos se puede construir un árbol).</p>      <p>2. Reemplazar cada punto estructural por una función de acuerdo a la tarea que se desee realizar (las funciones que reemplazarán a los constructores se disponen en una tupia denominada álgebra). Cada función que reemplaza a cada constructor tendrá como argumentos, además de la información de estado, los resultados de lo calculado por su padre (atributo heredado) y de lo calculado por sus hijos (atributos sintetizados). En virtud a la evaluación &quot;lazy&quot;, será posible que un mismo atributo sea heredado y sintetizado al mismo tiempo (ver atributo fila en la definición de el Algoritmo 3).</p>      ]]></body>
<body><![CDATA[<p>Esta idea aplicada al árbol rosa está esquematizada en la Figura 4 y codificada mediante la función <i>foldJTree </i>(Algoritmo 2). Para implementar cada una de las operaciones de edición se hará uso de esta función escogiendo el álgebra adecuada <i>(nodo, cons, vacía) </i>que reemplazará a los constructores <i>Nodo, </i>(:), [] respectivamente.</p>        <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/fold_Tree.JPG" width="751" height="328"><br clear=all> </p>       <p><b>Figura 4:</b> <i>fold-Tree </i>reemplaza los constructores <i>Nodo,(:)y[] </i>(árbol izquierdo) por las funciones <i>nodo, cons y vacia </i>(árbol derecho) respectivamente.</p> <hr>     <p><b>Algoritmo 2: </b>La función <i>fold-Tree </i>reemplaza los constructores <i>(Nodo, </i>(:), []) por las funciones del álgebra <i>(nodo, cons, vacía). </i>La función nodo indica qué hacer al visitar un nodo, cons indica qué hacer al visitar cada hijo en la lista de descendientes del nodo, <i>vacía </i>indica qué hacer cuando la lista de descendientes se termina.</p>      <p>folcLTree   (nodo,cons,vacia)   = fold</p>      <p>where  fold   (Nodo  x xs)=nodo  x   (foldLista  cons  vacia   (map fold xs))) </p>     <p>foldLista f  a   [ ]   =  a </p>     <p>foldLista   f  a   (x:xs)= f  x   (foldLista f    a xs)</p><hr>     <p>En las siguientes secciones se define cada una de las operaciones de edición utilizando el modelo de programa presentado. Se hace una explicación minuciosa únicamente de una de las operaciones (cálculo de las posiciones de despliegue), para detalles del resto consultar la referencia [1].</p>      <p><b>3.3 Operaciones de despliegue</b></p>      ]]></body>
<body><![CDATA[<p><i><b>3.3.1 Cálculo de las posiciones de despliegue para la presentación</b></i></p>      <p>Para calcular la posición de despliegue de cada componente, se deben resolver los si­guientes problemas:</p>      <p>&bull; El cálculo de la fila y columna depende del espacio que ocupa cada carácter que se despliega en pantalla, lo que a su vez depende del tipo de letra usado.</p>      <p>&bull; El cálculo de la columna donde se debe desplegar un elemento, estará en función al nivel de profundidad que éste tiene en el árbol y el cálculo de su fila, en función a la regla:   &quot;desplegar los subárboles en el mismo orden en que aparecen en la</p> <hr>       <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/Fig5Apa.JPG" width="761" height="226"></p>     <br clear=all>         <p><b>Figura 5:</b> Observando la gráfica izquierda, se puede apreciar que calcular la posición del nodo sombreado no es fácil, sólo se podrá saber su fila una vez conocidas las filas de todos los demás. La gráfica de la derecha describe el modo de calcular las posiciones de despliegue de cada nodo del árbol rosa. El subárbol sal hereda la fila de su padre Nodo (flecha 1), el subárbol sal sintetiza su última fila y la pasa a su hermano (flecha 2), el subárbol sa2 hereda la fila de su hermano sal, el último subárbol san pasa la fila a su padre (flecha 4), para que éste a su vez la pase a su padre.</p><hr>     <p>lista&quot;.  Notar que sólo se podrá saber la fila del subárbol (n+1), una vez que se conozca la fila del subárbol n (Figura 5 izquierda).</p>      <p>El primer problema será resuelto mediante el uso de un único tipo de letra, para saber exactamente el alto y ancho de cada carácter (información que estará en h_offset y v_offset respectivamente). Para generalizar a cualquier tipo de letra, bastará abstraer el cálculo de estos dos valores en una función.</p>      <p>El segundo problema, se resuelve fácilmente en virtud a la evaluación &quot;lazy&quot; y al modelo de programa utilizado. Se calcularán las posiciones de despliegue como se ilustra en la Figura 5 (derecha).</p>      <p>Por tanto, el árbol original que desea editarse será mapeado a un árbol con in­formación de estado y será sobre éste que se trabajará durante la interacción con el usuario.</p>      ]]></body>
<body><![CDATA[<p>La idea anteriormente explicada se plasmó en la función <i>arbollnformado, </i>que se implementa en el Algoritmo 3.</p>      <p><b><i>3.3.2    Algebra de la función arbollnformado:   (infojnodo,  info-cons,   in-fo-vacia)</i></b></p>      <p><b>info_nodo e es c f </b>: Recibe la información de estado del nodo (e), la lista de descen­dientes del nodo (es), la columna (c) y fila (f) donde debe desplegarse el nodo. Retorna una tupia (f,arb), donde:</p>      <p><b>f=siguiente </b>fila a la última que ocupó el árbol cuya raíz es el nodo en cuestión.</p>      <p><b>arb=árbol </b>que obedeciendo a la estructura del árbol original, guarda en sus nodos la información de estado.</p><hr>      <p><b>Algoritmo 3 </b>: Código Haskell de la función que calcula la información de estado del árbol. Recibe un árbol <i>a, </i>una columna c y fila /, que es el punto en pantalla donde empieza a desplegarse el árbol. Calcula un nuevo árbol que guarda en sus nodos la tripla <i>(pos, cad, False) </i>que corresponde a la posición de depliegue, cadena a desplegarse para representar el nodo y no seleccionado respectivamente. Notar que en la función <i>info-nodo, </i>el valor <i>fi </i>que es usado en el resultado es calculado por la propia función, esto es posible en virtud a la evaluación &quot;lazy&quot;. Notar en las líneas 4, 8 y 12 que e y <i>es </i>están en la propia estructura ye,/ son atributos heredados.</p>      <p>1)&nbsp;&nbsp;&nbsp; arbollnformado::Árbol Estado — &gt; Int — &gt; Int — &gt; Árbol Estado</p>      <p>2)&nbsp;&nbsp;&nbsp; algebraArbolInformado=(info_nodo,info_cons,vacia)</p>      <p>3)   arbollnformado  a c f=snd(folcLTree  algebraArbolInformado   a c f)</p>      <p>4)   info_nodo e es c f</p>      ]]></body>
<body><![CDATA[<p>5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = let   (fi.xs)   = es   (c+h_offset)(f+v_offset)</p>      <p>6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cad=if  length xs==0 then  &quot;Hoja&quot;++show  e  else   &quot;Nodo&quot;</p>      <p>7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in   (fi.Nodo   ((c,f),cad,False)   xs)</p>      <p>8)  info_cons e es c f</p>      <p>9)           = let   (fi,x)   =e  c f</p>      <p>10)          (fi2,xs)=es  c fi</p>      <p>11)           in   (fi2,x:xs)</p>      <p>12)   vacia c f =(f,[ ])</p><hr>      <p>Analizando el código del Algoritmo 3, en la línea 5 (expresión derecha) info_nodo pasa a sus descendientes (es) la fila y columna donde deben empezar su despliegue, por tanto éstos son atributos heredados y en la línea 5 (expresión izquierda) info_nodo recibe de sus descendientes (es) la última fila (fi) que ocuparon, por tanto fila es un atributo sintetizado.</p>      <p><b>info_cons </b>e es <b>c f </b>: Recibe el primer árbol e y el resto de los árboles (es) de la lista de descendientes que acompaña a Nodo, la columna (c) y fila (f); retorna una tupia (f,lista), donde:</p>      ]]></body>
<body><![CDATA[<p><b>f=fila </b>donde se despliega el último elemento de la lista de árboles (lista).</p>      <p><b>lista=lista </b>de árboles descendientes con su respectiva información de estado.</p>      <p>Analizando el código del Algoritmo 3, en la línea 9 (expresión derecha) info.cons pasa a su primer descendiente (e) la columna y fila donde debe empezar a desplegarse, por tanto c y f son atributos heredados. En la línea 9 (expresión izquierda) info_cons recibe de su primer descendiente (e) la siguiente fila a la última que ocupa e (fi), por tanto fi es un atributo sintetizado. En la línea 10 (expresión derecha) info_cons pasa al resto de sus descendientes (es) la columna (que recibió de su padre) y la fila (fi)que recibió de su anterior descendiente (e). En la línea 10 (expresión izquierda), info_cons recibe del resto de sus descendiente (es) la siguiente fila a la última que ocuparon (fi2), por tanto fi2 es un atributo sintetizado.</p>      <p><b>vacia c f: </b>Recibe una columna (c) y fila (f) que es heredada de su padre y retorna una tupia (f,[ ]) para terminar de construir la lista de descendientes (linea 5 : xs) y retornar la última fila que ocupó la lista de árboles descendientes de Nodo.</p>     <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/Figura6Apa.JPG" width="703" height="169"></p>     <p><b>Figura 6:</b> Al seleccionar una hoja, ésta se muestra de diferente color, al seleccionar un nodo no terminal, éste y toda su descendencia se muestran de diferente color.</p><hr>     <p><b>Algoritmo 4: </b>Despliega el árbol a en la ventana <i>w, </i>mostrando con color c lo selecciona­do (marca=True) y con color neutro, lo no seleccionado (marca = false). Las funciones <i>escribe2, rojo, neutro </i>se pueden encontrar en la referencia [1].</p>      <p>neutro=rojo</p>      <p><b>muestraArbol::Árbol Estado - &gt;Window - &gt; RGB - &gt; IO()</b></p>      <p><b>algebraMuestraArbol=(muestraNodo,muestraCons, muestra Vacia)</b></p>      ]]></body>
<body><![CDATA[<p>muestraArbol  a w c=fold_Tree  algebraMuestraArbol   a w  c</p>      <p><b>muestraNodo (pto,v,m)</b> xs w color</p>      <p> = (if m then escribe  color  else  escribe  neutro)»(xs  w color) </p>     <p>where  escribe=ctext2  w pto  v</p>     <p><b>muestraCons</b> e es w color =   (e w color)   »   (es w  color)</p>      <p><b>muestraVacia</b> w color=return()</p><hr>      <p><b><i>3.3.3 Despliegue del árbol y sus componentes seleccionados</i></b></p>      <p>Cada nodo se despliega de acuerdo a su información de estado; se muestran las sec­ciones seleccionadas de un color y las no seleccionadas de otro, mediante la función muestraArbol (Algoritmo 4):</p>      <p>Para borrar el árbol de la pantalla, bastará con desplegarlo utilizando el color de fondo de la pantalla, utilizando la función muestraArbol (Algoritmo 4).</p>      <p><b>3.4 Operaciones de navegación/selección</b></p>      ]]></body>
<body><![CDATA[<p><b><i>3.4.1 Aspectos a considerar</i></b></p>      <p>Para lograr que el usuario pueda seleccionar el elemento del árbol que desea editar, se determinarán áreas sensibles a la presión del mouse y colores que indiquen las zo­nas seleccionadas. Si el usuario presiona el mouse sobre un nodo, éste con toda su descendencia se marcará de otro color (ver Figura 6):</p>      <p>Para permitir que el usuario pueda seleccionar áreas de la estructura:</p>      <p>• Se debe detectar el punto de la pantalla donde el usuario presionó el mouse así como verificar si éste está en un componente del árbol.</p>      <p>• En función a esta selección, desplegar el árbol de otro color para que la acción del usuario tenga eco en la interfaz usada para la edición.</p>      <p>• En caso de que el componente seleccionado sea un nodo no terminal, se debe asumir que el usuario desea seleccionarlo junto con toda su descendencia.</p>      <p>Para saber si el mouse tocó un componente del árbol, se necesita conocer el área que éste ocupa en pantalla. El cálculo del área estará en función al tipo de letra usado y a la cantidad de caracteres que se estén desplegando para representar el nodo. De este modo, si anchoArea es la cantidad de pixeles que ocupa la cadena que se despliega para representar el componente y altoArea es la cantidad de pixeles que tiene el alto de un carácter, entonces se sabría que el mouse (colMouse,filaMouse) tocó el componente cuya esquina superior izquierda es (col,fila) cuando se cumplan simultáneamente las siguientes condiciones:</p>      <p align="left">ColMouse &gt;= col </p>     <p align="left">ColMouse &lt;= col+anchoArea  </p>     <p align="left">FilaMouse &gt;= fila </p>     ]]></body>
<body><![CDATA[<p align="left">FilaMouse &lt;= fila+altoArea</p>     <p>Para resolver el problema de que la selección de un nodo no terminal debe implicar la selección de toda su descendencia, se adoptará la siguiente idea:</p>      <p>• Si un nodo fue tocado por el mouse, el valor de su marca toma el valor True.</p>      <p>• Si un nodo no fue tocado por el mouse, hereda el valor de marca de su padre.</p>     <p>En el Algoritmo 5 se presenta la función que abstrae lo explicado (Cabe destacar que esta funci&oacute;n podr&aacute; ser usada para dos efectos diferentes: marcar y desmarcar) .</p> <hr>     <p><b>Algoritmo 5</b>: La función <i>marca Árbol </i>recibe un árbol (a), el punto donde se presionó el mouse <i>{mouse) </i>y el tipo de operación deseada <i>(mark). </i>Marca (si mark es True) o desmarca (si mark es False) el nodo del árbol <i>a </i>que fue tocado por el mouse y todos los elementos descendientes de él. La función devolverá un árbol con su información de estado modificada de acuerdo a la selección.</p>      <p><b>marcaArbol::Árbol Estado — &gt; Bool — &gt; Pos — &gt; Bool — &gt; Árbol Estado </b></p>     <p><b>algebraMarcaArbol   =(marcaNodo,marcaCons,marcaVacia)</b></p>     <p>marcaArbol  a mPadre mouse mark=f olcLTree <b>algebraMarcaArbol</b> mPadre mouse mark </p>     <p><b>marcaNodo (pto,v,m)</b>  es   marcaPadre ptoMouse mark </p>     ]]></body>
<body><![CDATA[<p>=Nodo   (pto,v,nm)   (es nm ptoMouse mark)</p>     <p>where nm=if   (toca ptoMouse  pto)   then mark else marcaPadre </p>     <p><b>marcaCons</b> x xs   marcaPadre  ptoMouse mark</p>     <p>=   (x marcaPadre  ptoMouse mark):(xs marcaPadre  ptoMouse mark) </p>     <p><b>marcaVacia</b>   marcaPadre  ptoMouse mark= [ ]</p><hr>     <p><b>3.5 Operaciones de manipulación/transformación</b></p>      <p>En general, cada vez que se realiza una modificación en el árbol, se debe hacer una actualización del mismo, de modo que se pueda continuar la interacción con la nueva versión.</p>      <p>Para transformar el árbol, es requisito que el componente sobre el que se realizará la transformación, esté marcado. Por tanto, cada una de las operaciones de transformación que se describen a continuación tienen efecto sobre el componente &quot;seleccionado&quot; de la estructura.</p>      <p><b><i>3.5.1 Modificar el contenido de una hoja</i></b></p>      <p>Requiere buscar la hoja elegida, cambiar su contenido y actualizar el despliegue (Algo­ritmo 6).</p><hr>      ]]></body>
<body><![CDATA[<p><b>Algoritmo 6: </b>Cambia el valor que guarda la hoja seleccionada de <i>a </i>por el valor <i>nv. </i>Si el nodo está marcado (m==True) y es una hoja, cambia su contenido por <i>nv, </i>en caso contrario el contenido del nodo <i>n </i>no es modificado.   Nótese que <i>nv </i>es un parámetro heredado.</p>      <p><b>cambiaHoja::Árbol Estado — &gt; Valor — &gt; Árbol Estado</b></p>      <p><b>algebraCambiaHoja=(cHojaNodo,cHojaCons,cHojaVacia)</b></p>      <p>cambiaHoja a nv= folcLTree <b>algebraCambiaHoja</b> a </p>     <p><b>cHojaNodo n@(pto,v,m)</b> xs nv</p>     <p>=if m &amp;&amp;  length   (xs nv)==0  then Nodo   (pto,&quot;Hoja&quot;++nv,False)    (xs nv) </p>     <p>else Nodo   n   (xs  nv) </p>     <p><b>cHojaCons</b> e es nv=(e nv) : (es  nv) </p>     <p><b>cHojaVacia</b> nv= [ ]</p><hr>     <p><b><i>3.5.2 Transformar una hoja en rama</i></b></p>      ]]></body>
<body><![CDATA[<p>La transformación de una hoja en rama requiere, al igual que en el anterior caso, identi­ficar la hoja seleccionada, borrar la versión anterior del árbol y redesplegar la nueva, ya que las posiciones de despliegue de los elementos ubicados en filas posteriores al afectado bajan tantos niveles como componentes tenga la nueva rama (ver Algoritmo 7).</p>      <p><b><i>3.5.3 Transformar una rama en una hoja</i></b></p>      <p>Las posiciones de despliegue de los elementos ubicados en filas posteriores al elemento afectado deben subir tantos niveles como filas haya ocupado la rama transformada (ver Algoritmo 8).</p>      <p>En los tres casos de transformación, el árbol devuelto queda sin marcas.</p><hr>      <p><b>Algoritmo 7: </b>Si el nodo está marcado (m=True), es vulnerable a la operación, por lo que es transformado en no terminal con <i>nh </i>hojas que guardan el valor 0. Para los nodos no marcados (m=False), si la posición de despliegue (c, /) está en una fila posterior a la posición del nodo modificado <i>(cm, fm), </i>se cambia el valor de su posición de despliegue bajando su fila <i>nh </i>posiciones para dar espacio a los nuevos elementos que se han creado.</p>      <p><b>1) </b><b>h2rÁrbol::Árbol Estado - &gt; Int - &gt; Pos - &gt; Árbol Estado</b></p>      <p><b>2) </b><b>algebra_h2r=(h2rNodo,h2rCons,h2rVacia)</b></p>      <p>3) h2rArbol  = fold.Tree  algebra_h2r</p>      <p>4) h2rNodo  e@((c,f),v,m)   es  nh   (cm.fm)</p>      <p>5) &nbsp;&nbsp;=if m then Nodo ((c,f),&quot;Nodo&quot;,False)(foldr g [ ] [l..nh])</p>      ]]></body>
<body><![CDATA[<p>6) &nbsp;&nbsp;else Nodo((c,nf),v,m) (es nh (cm.fm))</p>      <p>7) &nbsp;&nbsp;where</p>      <p>8) &nbsp;&nbsp;&nbsp;&nbsp;nf=if f&gt;fm then (f+nh*v_offset) else f</p>      <p>9) &nbsp;&nbsp;&nbsp;&nbsp;g x xs=(Nodo((c+h_offset,f+x*v_offset),&quot;Hoja 0&quot;,False)[ ]):xs</p>      <p>10)  h2rCons t ts nh ptoMouse=(t nh ptoMouse):(ts nh ptoMouse)</p>      <p>11) h2rVacia nh ptoMouse=[ ]</p>      <p>Lo interesante de la solución planteada es que para las tres operaciones de transfor­mación, la identificación de la selección (sobre la que se debe aplicar la transformación) es automática, es decir, no se usa una función especial para identificar el área selec­cionada, se aplica la función de transformación a todo el árbol y únicamente los nodos seleccionados se ven afectados (Otras implementaciones similares usan un modelo que obliga a que la identificaci&oacute;n de la selecci&oacute;n requiera de una funci&oacute;n especial, ver referencias [8, 7, 5]).</p> <hr>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>4 Hacia el editor genérico</B></font></p>      <p>Una buena táctica para desarrollar aplicaciones generales es seguir el ciclo abstracción-especialización; en un proceso de <i>abstracción </i>en el que se eliminan detalles irrelevantes, se obtiene un producto de propósito general (un modelo esencial); en el proceso de <i>especialización </i>se instancia el producto general para satisfacer requerimientos particu­lares [2]. Lo atractivo de esta forma de trabajo es poder reusar estos productos generales que al tener la condición de &quot;esenciales&quot; pueden ser usados como patrones de programas.</p>      <p>Es en búsqueda de este producto de propósito general que la presente sección tiene su justificación. En efecto, se presenta un escenario para lograr un generador de editores de estructuras que pueda editar un árbol de cualquier tipo. En un proceso de especia­lización, se toma la aplicación de propósito general (la abstracción) y se la modifica para que se convierta en una aplicación de propósito específico (la especialización). Las modificaciones que se deban hacer sobre la aplicación general para obtener el producto especializado es un indicador de cuan buena es la abstracción usada y puede servir como un instrumento para llevar a cabo un proceso de refinamiento de este modelo esencial. En esta sección se lleva a cabo la especialización del editor rosa a editores particulares</p><hr>      ]]></body>
<body><![CDATA[<p><b>Algoritmo 8 </b>: Si la marca del nodo (m) es True, éste debe ser transformado en hoja, retornando Nodo ((c,f), &quot;Hoja 0&quot; ,False). Si la posición de despliegue del nodo en cuestión (c,f) está en una fila de la pantalla posterior a la fila de la posición de la rama que se está transformando (cm,fm), entonces se recalcula (c,f), disminuyéndole tantas filas como descendientes tenga el nodo (niv).</p>      <p><strong>r2hArbol::  Árbol Estado — &gt; posición — &gt; Int — &gt; Árbol Estado</strong></p>      <p><strong>algebra_r2h=(r2hNodo,r2hCons,r2hVacia)</strong></p>      <p>r2hArbol  a  (cm.fm)   niv= folcLTree <strong>algebra_r2h</strong> a   (cm.fm)   niv</p>      <p><strong>r2hNodo ((c,f),v,m)</strong> es   (cm.fm)   niv</p>      <p>&nbsp;&nbsp;&nbsp;=if m then Nodo   ((c,f),+&quot;Hoja 0&quot;,False)    [ ]   else  árbol </p>     <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where nf=if  f&gt;fm   then   (f-niv*v_offset)   else  f </p>     <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arbol=Nodo   ((c,nf),v,m)   (es   (cm.fm)   niv) </p>     <p><strong>r2hCons</strong> t  ts ptoMouse    niv=(t  ptoMouse  niv) : (ts  ptoMouse  niv) </p>     <p><strong>r2hVacia</strong> ptoMouse niv =   [ ]</p><hr>     ]]></body>
<body><![CDATA[<p>y siguiendo el ciclo abstracción-especialización, se muestra un proceso de refinamiento hasta la obtención de una abstracción razonable. La idea general que se seguirá para llevar a cabo la especialización es la aplicación de &quot;mapeamientos&quot; de valores del tipo x al tipo rosa y viceversa: la idea es convertir cualquier entrada que obedezca al tipo x al tipo rosa, manipular la estructura con el editor rosa y finalmente convertir la estructura rosa al tipo x. Lo indicado se ilustra en la Figura 7:</p>     <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/Fig7Apa.JPG" width="697" height="231"></p>     <p><b>Figura 7:</b> Modelo Abstracción-Especialización aplicado al editor de estructuras.</p>      <p>Siguiendo esta idea, se presentan a continuación algunos ejemplos de especializacio-nes tomando como abstracción el editor presentado en la sección precedente.</p>      <p><b>4.1 Especialización cambiando el código fuente </b></p>     <p><b><i>4-1.1 Abstracción</i></b></p>     <p>Tomando como abstracción el editor cuyas funciones esenciales se presentan en la sección 3 y que tiene como función principal de interacción la siguiente:</p><hr>     <p>  <b>Algoritmo 9 </b>: Código Haskell de la función principal del editor de árboles   rosa que permite la interacción y hace referencia a las funciones de edición   esenciales explicadas en la sección 3. <i>La función completa puede ser encontrada     en la referencia [1].</i></p>     <p>1) edita a</p>      <p>2)           =  let  loopl  w ai</p>  ........................................         ]]></body>
<body><![CDATA[<p><b>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>Closed  — &gt;  return ai</p>      <p>........................................</p>       <p>50) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ejec (h2rArbol olda (car2num car) pt) loopl w olda</p>      <p>57) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let ai=arbolInformado a 1 1</p>      <p>58) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w &lt;- openWindow &quot;Edici&oacute;n de Arboles n-arios&quot;(620,400)</p>      <p>59)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  muestraArbol ai w azul</p>      <p>60) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; men&uacute; w listaOpciones agua (colMenu.filaMenu)</p>     <p>..........................................</p><hr>     <p><b><i>4.1.2    Especialización a editor de árboles binarios</i></b></p>      <p>Para especializar a un árbol binario (Deflnici&oacute;n de tipo de un &aacute;rbol binario: data B a = Bhoja a | Brama (B a)(B a)) se debería convertir el árbol binario a árbol rosa, manipular la estructura como árbol rosa mediante la abstracción, controlar que durante la edición el árbol cumpla la condición de ser binario (que las longitudes de las listas sean 2 o 0) y finalmente convertir el árbol rosa en árbol binario.</p>      ]]></body>
<body><![CDATA[<p>Para implementar lo indicado, se deberían definir las funciones de conversión y hacer algunos cambios en el código de la función edita (Algoritmo 9).</p>      <p><b>Definición de las funciones</b></p>      <p>bin2rosa (Hoja x)= Nodo x [ ]</p>      <p>bin2rosa (Rama e i d)= Nodo e [bin2rosa i, bin2rosa d]</p>      <p>rosa2bin (Nodo x [ ]) = Hoja x</p>      <p>rosa2bin (Nodo x i:d:[ ]) = Rama x (rosa2bin i) (rosa2bin d)</p>      <p><b>Cambio en el código    </b>El código de la función edita (Algoritmo 9) debería cambiar como se ilustra en el Algoritmo 10:</p>      <p>Lo malo de la abstracción usada es que el hacer especialización implica cambiar el código, lo cual es un indicador de que ésta podría ser refinada.</p>      <p><b>4.2 Especialización mediante parametrización</b></p>      <p>Si se colocan como parámetros de la función edita las <i>funciones de transformación </i>y el <i>grado del árbol </i>entonces una especialización solo requeriría llamar a la función edita con</p><hr>      ]]></body>
<body><![CDATA[<p><b>Algoritmo 10</b>: Cambian las líneas 4, 50 y 57, se borran las líneas 45 a 49. Notar que las partes esenciales del programa que se explican en la sección 3 no se ven afectadas.</p>      <p>1)    edita a</p>      <p>2)           =  let  loopl  w ai</p>     <p>.....................................</p>     <p><b>4) </b>           Closed &mdash; &gt; return (<strong>rosa2bin</strong> ai)</p>     <p>.....................................</p>     <p>50)        ejec (h2rArbol&nbsp; olda 2 pt) loopl&nbsp; w olda</p>     <p>57)        let&nbsp; ai=arbolInformado&nbsp;&nbsp; (<strong>bin2rosa</strong> a)&nbsp;&nbsp; 1&nbsp;&nbsp; 1</p>     <p>......................................</p><hr>     <p>los parámetros adecuados y no sería necesario cambiar el código. Para ello se tendría que cambiar la función edita (Algoritmo 10) como se muestra en el Algoritmo 11.</p>      ]]></body>
<body><![CDATA[<p><b><i>4-2.1 Abstracción</i></b></p> <hr>     <p><b>Algoritmo 11</b>: Código Haskell de la abstracción parametrizada. Las funciones de con­versión de estructuras <i>(x2rosa </i>y <i>rosa2x) </i>así como el grado <i>(nroHijos) </i>son parámetros de la función (línea 1).</p>      <p>1)&nbsp;&nbsp;&nbsp;&nbsp; edita x2rosa rosa2x nroHijos  a</p>      <p>2) = let loopl w ai</p>     <p>......................................</p>     <p>4) Closed -&gt; return (rosa2x ai)</p>     <p>.....................................</p>     <p>50)       ejec (h2rArbol olda nroHijos pt)   loopl w olda</p>     <p>56)   in do</p>      <p>57)       let  ai=arbol!nformado   (x2rosa a)   1   1</p>     ]]></body>
<body><![CDATA[<p>......................................</p><hr>     <p>En estas condiciones, el editor puede ser utilizado para manejar cualquier árbol, siempre y cuando se den como parámetros las funciones de conversión, de acuerdo al tipo de árbol a editarse.</p>      <p><b><i>4-2.2 Especialización a un editor de árboles de grado n</i></b></p>      <p>rg (edita <b>bin2rosa rosa2bin 2 </b>arbolTipoB) (Especialización a un árbol binario) </p>     <p>rg (edita <b>ter2rosa rosa2ter 3 </b>arbolTipoT)   (Especialización a un árbol ternario)</p>     <p>La abstracción ahora obtenida es mejor en el sentido que se obtiene una especia­lización tan solo pasando los parámetros adecuados a la expresión que usa el editor general; sin embargo, las funciones que convierten de un tipo de estructura a la otra tienen diferentes nombres cuando en esencia tienen el mismo rol.</p>      <p><b>4.3 Especialización mediante clases (primera versión)</b></p>      <p>Se podría crear una clase para sobrecargar las funciones de transformación x2rosa y rosa2x, en cuyo caso éstas ya no tendrían que ser parámetros de edita. El editor automáticamente reconocería la estructura y trabajaría con la instancia x2rosa, rosa2x correspondiente.</p>      <p><b><i>4-3.1 Abstracción</i></b></p>      <p>Se añade la clase del Algoritmo 12 y se borran los parámetros (x2rosa, rosa2x y nroHijos) de la línea 1 del código del Algoritmo 11.</p><hr>      ]]></body>
<body><![CDATA[<p><b>Algoritmo 12 </b>: La clase <i>ToFromRosa </i>agrupará todas las estructuras que el editor reconocerá.</p>      <p>       class  ToFromRosa a b where</p>      <p>       x2rosa::b-&gt;RosaTree  a</p>      <p>       rosa2x::     RosaTree  a -&gt; b</p>      <p>       nroHijos::Int</p><hr>      <p><b><i>4-3.2    Especialización a un árbol binario</i></b></p>      <p>instance ToFromRosa a (B a) where </p>     <p>       x2rosa (Bhoja y)= Nodo y [ ]</p>     <p>       x2rosa (Brama y i d)= Nodo y [x2rosa i, x2rosa d] </p>     <p>       rosa2x (Nodo y [   ])= Bhoja y</p>     ]]></body>
<body><![CDATA[<p>       rosa2x (Nodo y [i,d])=Brama y (rosa2x i)( rosa2x d) </p>     <p>       nroHijos=2</p>     <p><b><i>4.3.3    Especialización a un árbol ternario</i></b></p>      <p>instance  ToFromRosa a   (T  a)   where</p>     <p>       x2rosa   (Thoja y)= Nodo  y   [ ]</p>     <p>       x2rosa   (Trama i m d)= Nodo y   [x2rosa i,   x2rosa m,   x2rosa d] </p>     <p>       rosa2x   (Nodo  y   [ ])= Thoja y</p>     <p>       rosa2x   (Nodo  y   [i,m,d])=Trama y   (rosa2x  i)   (rosa2x m)(rosa2x d) </p>     <p>       nroHijos=3</p>     <p>Notar que, en esta oportunidad la especialización se vuelve transparente al usuario. Bastará con instanciar en la clase ToFromRosa el nuevo tipo de datos, lo que básicamente significa definir las funciones de conversión y el grado del árbol. Ahora se podrá utilizar la función edita con cualquier estructura cuyo tipo de datos pertenezca a la clase ToFromRosa:</p>      ]]></body>
<body><![CDATA[<p>       rg (edita <b>(Brama (Bhoja2) (Bhoja 3))) </b><sup>1</sup></p>      <p>       rg (edita <b>(Trama (Thoja2) (Thoja 3) (Thoja 4))) </b><sup>2</sup></p>      <p>       Lo negativo de esta solución es que sólo permite manejar árboles con grado constante.</p>      <p><b>4.4     Especialización mediante clases (segunda versión)</b></p>      <p>Se podría generalizar la abstracción de modo que permita manejar árboles con grado menor a una constante, con lo cual se podrían hacer especializaciones a una gran gama de editores.</p>      <p><b><i>4-4-1     Abstracción</i></b></p>      <p>Añadir a la clase ToFromRosa (Algoritmo 12) la función <i>compara :: Int —&gt; Int —&gt; Bool.</i></p>      <p>Esta función daría la libertad de manejar árboles de grado constante (==) o árboles de grado menor o igual a una constante (&lt;=).</p>      <p><b><i>4.4.2    Especialización a un árbol ternario</i></b></p>      <p>instance ToFromRosa a (T a) </p>     ]]></body>
<body><![CDATA[<p>       where x2rosa   (Thoja y)= Nodo y [ ]</p>     <p>       x2rosa (Trama i m d)= Nodo &quot; &quot; [x2rosa i,x2rosa m,x2rosa d] </p>     <p>       rosa2x (Nodo y [ ])= Thoja y</p>     <p>       rosa2x (Nodo y [i,m,d])=Trama y (rosa2x i)(rosa2x m) (rosa2x d )</p>     <p>       nroHijos=3  </p>     <p>       compara=(==)</p>     <p><b><i>4.4.3    Especialización a un árbol bin-ternario (del tipo BT)</i></b></p>      <p><b>Definición:</b></p>      <p>data BT a=BThoja a | BTrama2 a (BT a)(BT a) | BTrama3 a (BT a)(BT a)(BT a).</p>      <p>Nótese que:</p>      ]]></body>
<body><![CDATA[<p>• Añadiendo a la clase ToFromRosa la función compara, se da mayor generalidad a la abstracción. La idea que subyace a esta función es permitir especializar árboles de grado constante o menor o igual a una constante.</p><hr>      <p><sup>1</sup>Deflnición de tipo de un árbol binario: data B a = Bhoja a | Brama (B a)(B a). </p>     <p><sup>2</sup>Deflnición de tipo de un   árbol ternario: data T a = Thoja a | Trama (T a)(T a)(T a).</p> <hr>         <p align="center"><img src="../../../../../SciELO/serial/ran/v1n2/pdf//img/revistas/ran/v1n2/Algo2Apa.JPG" width="663" height="236"></p>     <p>&bull; Aún existen árboles que no podrían   ser especializados mediante la instanciación, es el caso de aquellos que   tuvieran por ejemplo nodos con 5 hijos y nodos con 3 hijos. Sin embargo, esto   también podría ser generalizado añadiendo a la clase una lista que guardaría   los grados que se aceptan en el árbol. En tal caso la función   &quot;compara&quot; ya no sería necesaria. </p>     <p>&bull; Se ha llegado a un punto en que la especialización no requiere modificación alguna al código, en efecto, especializar se reduce a definir las funciones de transformación y el grado (como instancias de la clase ToFromRosa).</p>      <p><b><font size="3" face="Verdana, Arial, Helvetica, sans-serif">5 Conclusiones</font></b></p>      <p>1. El editor de estructuras implementado es razonablemente general, de hecho tra­baja con muchos tipos de árboles. Si se quiere que el editor trabaje sobre un tipo de árbol particular, basta con instanciar la nueva estructura que se desea editar en la clase ToFromRosa.</p>      <p>2. Los resultados obtenidos en el trabajo son independientes de la interfaz, es sufi­ciente una terminal de caracteres con capacidad para direccionar de modo directo cada punto de la pantalla.</p>      <p>3. El modelo de programa propuesto es básicamente independiente de la herramienta gráfica que se esté utilizando, en efecto, haciendo pequeñas modificaciones en áreas concretas del programa (que no tocan la esencia del editor), se obtiene la aplicación con otras herramientas (Para este trabajo se utiliz&oacute; la librer&iacute;a de gr&aacute;ficos graphicsLib [6]).</p>      ]]></body>
<body><![CDATA[<p>4. Una versión más compacta de la aplicación obtenida podría construirse en base a la composición de fragmentos utilizados en esta aplicación. Por ejemplo, se podría intentar implementar más de una operación con un solo fold, bastaría con ver la forma de combinar las álgebras que aquí se han construido. Lo rescatable de la solución obtenida es que todas las funcionalidades esenciales están escritas en términos de álgebras.</p>      <p>5. En base a la experiencia obtenida al desarrollar el editor, se recomienda el siguiente método para llegar a soluciones &quot;generales&quot;:</p>      <p>• <b>Buscar un buen modelo de implementación con ejemplos simples que den lugar a una aplicación particular: </b>Analizar modelos y solucio­nes utilizando un ejemplo sencillo. Esto permite que el programador no se distraiga en detalles de un producto complicado y se concentre en aspectos esenciales para encontrar un buen modelo.</p>      <p>• <b>Aplicar  el modelo para obtener una aplicación general:   </b>Una vez encontrado un buen modelo, aplicarlo para el caso más general.</p>      <p>• <b>Aplicar el ciclo abstracción - especialización en busca de una aplicación genérica: </b>Para verificar que el producto obtenido sea una abstracción lo suficientemente general, tratar de especializarlo a productos particulares, buscando que esta especialización no implique modificar la aplicación general y sea lo más transparente posible para el usuario.</p>      <p><font size="3" face="Verdana, Arial, Helvetica, sans-serif"><B>6 Trabajo futuro</B></font></p>      <p>Todas las extensiones que se proponen a continuación son detalladas en la referencia [1].</p>      <p>&bull; Se puede, a partir de esta propuesta, construir un <i>generador de editores de estruc­turas </i>que reciba como entrada una gramática (tipo de datos) y retorne un editor de objetos que obedezcan a la misma. Esto implicaría la aplicación programación politípica (utilizar tipos de datos como argumentos de funciones) o convertir los tipos en valores de primera clase.</p>      <p>&bull; Se podría permitir que la estructura guarde elementos de diferentes tipos, bastaría con hacer una abstracción de datos que los agrupe en uno solo.</p>      <p>&bull; La solución propuesta podría ser extendida para obtener un editor de un árbol que permita guardar información en nodos no terminales. Esto en virtud a que el modelo usado para la solución guarda información en cada nodo (independien­temente de que éste sea terminal o no), simplemente que no se implementan las funcionalidades propias de un árbol de esas características. Por lo anterior, lo único que habría que hacer es dar la funcionalidad que corresponde sin necesidad de cambiar el modelo.</p>      ]]></body>
<body><![CDATA[<p>&bull; Permitir que el foco de selección pueda abarcar más de un subárbol a la vez es tarea fácil, para lograrlo, solo habría que activar una tecla como (ctrl+ la presión del mouse) para indicar que la selección continúa, guardar en una lista todos los puntos que han sido escogidos por el mouse y modificar la función de selección de modo que en lugar de recibir un punto (ptoMouse), reciba una lista de puntos. En tal caso solo se tendría que modificar la función &quot;toca&quot; de la operación de selección (ver referencia [1]), para que trabaje con una lista de puntos, pero el álgebra no necesita ser modificada.</p>      <p>• En cuanto a la interfaz, solo se manejan objetos rectangulares o cuadrados (texto). Para manejar objetos de diferentes formas, bastaría con tener los parámetros ne­cesarios para calcular sus áreas. El trabajo que se deba hacer puede ser capturado en la función &quot;toca&quot; sin que el resto del código cambie.</p>      <p>• En el editor de estructuras logrado, se tiene una sola forma de desplegar la estruc­tura: cada componente es desplegado en una fila diferente y se usan indentaciones para reflejar el nivel que tiene el componente dentro de la estructura. Todo esto es capturado en la función arbollnformado. Se podrían implementar otras formas de desplegar la estructura, siguiendo la misma idea. Otras formas de despliegue se pueden encontrar en la referencia [1].</p>      <p>• Es posible utilizar el editor de árboles rosa obtenido para editar documentos html, expresiones, lenguajes de programación, etc. Sin embargo, el usar el editor para estos objetos en las condiciones en las que está, significa trabajar artesanalmente ya que se deben elaborar cada una de sus construcciones desde cero. Por lo anterior, resultaría de mucha utilidad construir una librería de &quot;templates&quot; para los componentes estándares que tiene el objeto para el cual se quiere el editor.</p>      <p><b>Referencias</b></p>      <!-- ref --><p>[1] N.T. Aparicio.  Un editor genérico de estructuras.  Tesis de Maestría, Universidad Mayor de San Simón, 2001.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001281&pid=S1683-0789200100020000400001&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[2] R. Backhouse, P. Jansson, J. Jeuring, y L. Meertens.   <i>Generic Programming - An Introduction. </i>1998.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001282&pid=S1683-0789200100020000400002&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[3] R. Bird.    <i>Introduction to Functional Programming using Haskell.    </i>Prentice Hall Europe, University of Oxford, 2da. edición, 1998.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001283&pid=S1683-0789200100020000400003&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[4] R. Van Geldrop, J. Jeuring, y D. Swiestra. Deel 1 gramticas &amp; ontleden deel, 1998.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001284&pid=S1683-0789200100020000400004&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[5] W. Kahl, O. Braun, y J. Scheffczyk. Editor combinators - a first account. Reporte técnico, Universitát def Bundeswehr, Junio, 2000.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001285&pid=S1683-0789200100020000400005&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[6] A. Reid.   The hugs graphics library.   Reporte Técnico CT 06520, Departament of Computer Science, New Haven.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001286&pid=S1683-0789200100020000400006&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[7] T. Reps y T. Teitelbaum.   <i>The Synthesizer Generator- Reference Manual. </i>Depart­ment of Computer Science, Cornell University.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001287&pid=S1683-0789200100020000400007&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[8] B. Sufrin y O. de Moor. Modeless structure editing. Programming Research Group.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001288&pid=S1683-0789200100020000400008&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --><!-- ref --><p>[9] S. Thompson.   <i>The Craft of Functional Programming.   </i>Addison Wesley Longman Limited, 2da. edición, 1999.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#160;<a href="javascript:void(0);" onclick="javascript: window.open('/scielo.php?script=sci_nlinks&ref=001289&pid=S1683-0789200100020000400009&lng=','','width=640,height=500,resizable=yes,scrollbars=1,menubar=yes,');">Links</a>&#160;]<!-- end-ref --> ]]></body><back>
<ref-list>
<ref id="B1">
<label>[1]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Aparicio]]></surname>
<given-names><![CDATA[N.T.]]></given-names>
</name>
</person-group>
<source><![CDATA[]]></source>
<year></year>
</nlm-citation>
</ref>
<ref id="B2">
<label>[2]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Backhouse]]></surname>
<given-names><![CDATA[R.]]></given-names>
</name>
<name>
<surname><![CDATA[Jansson]]></surname>
<given-names><![CDATA[P.]]></given-names>
</name>
<name>
<surname><![CDATA[Jeuring]]></surname>
<given-names><![CDATA[J.]]></given-names>
</name>
<name>
<surname><![CDATA[Meertens]]></surname>
<given-names><![CDATA[L.]]></given-names>
</name>
</person-group>
<source><![CDATA[Generic Programming - An Introduction]]></source>
<year>1998</year>
</nlm-citation>
</ref>
<ref id="B3">
<label>[3]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Bird]]></surname>
<given-names><![CDATA[R.]]></given-names>
</name>
</person-group>
<source><![CDATA[Introduction to Functional Programming using Haskell]]></source>
<year>1998</year>
</nlm-citation>
</ref>
<ref id="B4">
<label>[4]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Van Geldrop]]></surname>
<given-names><![CDATA[R.]]></given-names>
</name>
<name>
<surname><![CDATA[Jeuring]]></surname>
<given-names><![CDATA[J.]]></given-names>
</name>
<name>
<surname><![CDATA[Swiestra]]></surname>
<given-names><![CDATA[D.]]></given-names>
</name>
</person-group>
<source><![CDATA[Deel 1 gramticas & ontleden deel]]></source>
<year>1998</year>
</nlm-citation>
</ref>
<ref id="B5">
<label>[5]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Kahl]]></surname>
<given-names><![CDATA[W.]]></given-names>
</name>
<name>
<surname><![CDATA[Braun]]></surname>
<given-names><![CDATA[O.]]></given-names>
</name>
<name>
<surname><![CDATA[Scheffczyk]]></surname>
<given-names><![CDATA[J.]]></given-names>
</name>
</person-group>
<source><![CDATA[Editor combinators - a first account]]></source>
<year>Juni</year>
<month>o,</month>
<day> 2</day>
</nlm-citation>
</ref>
<ref id="B6">
<label>[6]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Reid]]></surname>
<given-names><![CDATA[A.]]></given-names>
</name>
</person-group>
<source><![CDATA[The hugs graphics library]]></source>
<year></year>
</nlm-citation>
</ref>
<ref id="B7">
<label>[7]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Reps]]></surname>
<given-names><![CDATA[T.]]></given-names>
</name>
<name>
<surname><![CDATA[Teitelbaum]]></surname>
<given-names><![CDATA[T.]]></given-names>
</name>
</person-group>
<source><![CDATA[The Synthesizer Generator- Reference Manual.]]></source>
<year></year>
</nlm-citation>
</ref>
<ref id="B8">
<label>[8]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Sufrin]]></surname>
<given-names><![CDATA[B.]]></given-names>
</name>
<name>
<surname><![CDATA[de Moor]]></surname>
<given-names><![CDATA[O.]]></given-names>
</name>
</person-group>
<source><![CDATA[Modeless structure editing. Programming Research Group.]]></source>
<year></year>
</nlm-citation>
</ref>
<ref id="B9">
<label>[9]</label><nlm-citation citation-type="">
<person-group person-group-type="author">
<name>
<surname><![CDATA[Thompson]]></surname>
<given-names><![CDATA[S.]]></given-names>
</name>
</person-group>
<source><![CDATA[The Craft of Functional Programming]]></source>
<year>1999</year>
</nlm-citation>
</ref>
</ref-list>
</back>
</article>
