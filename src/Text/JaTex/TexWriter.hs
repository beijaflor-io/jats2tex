{-# LANGUAGE ConstraintKinds       #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE NamedFieldPuns        #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
module Text.JaTex.TexWriter
  where

import qualified Language.Haskell.Interpreter       as Hint
import Data.ByteString.Char8 as ByteString (unpack)
import Crypto.Hash
import           Control.Monad.Identity
import           Control.Monad.State
import           Data.HashMap.Strict (HashMap)
import qualified Data.HashMap.Strict as HashMap
import           Control.Monad.Writer
import           Data.Char              (isSpace)
import           Data.List
import           Data.Maybe
import           Data.Monoid
import qualified Data.Text              as Text
import qualified Data.Text.IO           as Text
import           Text.LaTeX
import           Text.LaTeX.Base.Class
import           Text.LaTeX.Base.Syntax
import           Text.XML.Light
import           JATSXML.HTMLEntities

import           Debug.Trace
import           System.Environment
import           System.IO

import           Text.JaTex.Parser
import           Text.JaTex.Template
import           Text.JaTex.Template.Types
import qualified Text.JaTex.Upgrade     as Upgrade
import           Text.JaTex.Util

type MonadTex m = (MonadState TexState m, MonadIO m)
type TexM = StateT TexState Identity

data TexState = TexState { tsFileName :: FilePath
                         , tsDebug :: Bool
                         , tsTemplate :: Template
                         , tsMetadata :: HashMap Text Text
                         , tsHeadRev     :: [LaTeXT Identity ()]
                         , tsBodyRev     :: [LaTeXT Identity ()]
                         }

emptyState :: TexState
emptyState = TexState { tsBodyRev = mempty
                      , tsHeadRev = mempty
                      , tsMetadata = mempty
                      , tsTemplate = defaultTemplate
                      , tsFileName = ""
                      , tsDebug = False
                      }

tsHead = reverse . tsHeadRev
tsBody = reverse . tsBodyRev

runTexWriter
  :: Monad m =>
     TexState -> StateT TexState m a -> m (TexState, LaTeX)
runTexWriter st w = do
  (_, newState) <- runStateT w st
  let hCmds = tsHead newState
      bCmds = tsBody newState
      (_, r) = runIdentity $ runLaTeXT (sequence_ (hCmds <> bCmds))
  return (newState, r)

convert :: MonadIO m => String -> Template -> JATSDoc -> m LaTeX
convert fp tmp i = do
  liftIO $ hPutStrLn stderr $ unlines [ "jats2tex@" <> Upgrade.versionName Upgrade.currentVersion
                                      , "Reading: " <> fp
                                      , "Using Template: " <> show tmp
                                      ]
  debug <- isJust <$> liftIO (lookupEnv "JATS2TEX_DEBUG")
  (_, t) <- runTexWriter emptyState { tsFileName = fp
                                    , tsTemplate = tmp
                                    , tsDebug = debug
                                    } (jatsXmlToLaTeX i)
  return t

jatsXmlToLaTeX
  :: MonadTex m
  => JATSDoc -> m ()
jatsXmlToLaTeX d = do
  add $
    comment
      (Text.pack
         (" Generated by jats2tex@" <>
          Upgrade.versionNumber Upgrade.currentVersion <>
          ":" <>
          fromMaybe "" (do
             binHash <- Upgrade.versionHash Upgrade.currentVersion
             digHash <- digestFromByteString binHash :: Maybe (Digest SHA1)
             return (ByteString.unpack (digestToHexByteString digHash)))))
  let contents = concatMap cleanUp d
  children <- mapM convertInlineNode contents
  let heads = sequence_ $ concatMap fst children
      bodies = sequence_ $ concatMap snd children
  add heads
  add bodies

convertNode
  :: MonadTex m
  => Content -> m ()
convertNode (Elem e) = do
  addComment "elem"
  convertElem e
convertNode (Text (CData CDataText str _))
  | str == "" || dropWhile isSpace str == "" = return ()
convertNode (Text (CData CDataText str _)) = do
  addComment "cdata"
  add $ fromString str
convertNode (Text (CData _ str ml)) = do
  addComment "xml-cdata"
  let cs =
        map
          (\c ->
             case c of
               Elem el -> Elem el {elLine = ml}
               _ -> c)
          (parseXML str)
  mapM_ convertNode cs
convertNode (CRef r) = do
  addComment "ref"
  add $ fromString (fromMaybe r (crefToString r))

addHead :: MonadState TexState m => LaTeXT Identity () -> m ()
addHead m = modify (\ts -> ts { tsHeadRev = m:tsHeadRev ts
                              })

add :: MonadState TexState m => LaTeXT Identity () -> m ()
add m = modify (\ts -> ts { tsBodyRev = m:tsBodyRev ts
                          })

addComment :: MonadState TexState m => Text -> m ()
addComment c = do
  isDebug <- tsDebug <$> get
  when isDebug (add (comment c))

convertElem
  :: MonadTex m
  => Element -> m ()
convertElem el@Element {..} = do
  TexState {tsTemplate} <- get
  commentEl
  templateContext <- getTemplateContext
  case findTemplate tsTemplate templateContext of
    Nothing -> run
    Just (c, t) -> do
      liftIO $ Text.hPutStrLn stderr ("Matched: " <> templateSelector c)
      (h, b) <- templateApply t templateContext
      addHead h
      add b
  where
    lookupAttr' k =
      attrVal <$> find (\Attr {attrKey} -> showQName attrKey == k) elAttribs
    n = qName elName
    commentEl =
      addComment
        (Text.pack
           (" <" <> n <> " " <> humanAttrs <> "> (" <> maybe "" show elLine <>
            ")"))
    humanAttrs =
      unwords $
      map
        (\(Attr attrKey attrValue) -> showQName attrKey <> "=" <> show attrValue)
        elAttribs
    -- commentEndEl =
    --   add $
    --   (comment (Text.pack ("</" <> n <> "> (" <> maybe "" show elLine <> "))")))
    getTemplateContext = do
      (h, i) <- convertInlineChildren el
      return TemplateContext {tcHeads = h, tcBodies = i, tcElement = el}
    run
      -- | n == /article" = do
      --   add $ documentclass [] article >> fromString "\n"
      --   (h, i) <- convertInlineChildren el
      --   add $
      --     begin "document" $ do
      --       sequence_ h
      --       maketitle
      --       sequence_ i
      -- | n == "?xml" = convertChildren el
      -- | n == "article-title" = do
      --   (h, inline) <- convertInlineChildren el
      --   addHead $ title (sequence_ (h <> inline))
      -- | n == "contrib-group" -- && lookupAttr' "contrib-type" == Just "author" =
      --  = do
      --   r <- mapM convertInlineChildren (elChildren el)
      --   addHead $
      --     author $
      --     forM_
      --       (intercalate
      --          [comm0 "and"]
      --          (map
      --             ((: []) . snd)
      --             (filter ((/= "") . runLaTeX . map . snd) r)))
      --       id
      -- | n == "body" = convertChildren el
      -- | n == "font" = do
      --   (h, i) <- convertInlineChildren el
      --   add $ textell (TeXBraces (runLaTeX (sequence_ (h <> i))))
      -- | n == "contrib" = convertChildren el
      -- | n == "back" = return ()
      -- | n == "abstract" = do
      --   (h, i) <- convertInlineNode (head elContent)
      --   add $ comm1 "abstract" (sequence_ (h <> i))
      -- | n == "name" = do
      --   s <-
      --     map snd <$>
      --     mapM
      --       convertInlineChildren
      --       (findChildren (QName "surname" Nothing Nothing) el)
      --   g <-
      --     map snd <$>
      --     mapM
      --       convertInlineChildren
      --       (findChildren (QName "given-names" Nothing Nothing) el)
      --   add $ do
      --     sequence_ s
      --     fromString ", "
      --     sequence_ g
      -- | n == "surname" = do
      --   convertChildren el
      --   add $ fromString ", "
      -- | n == "given-names" = convertChildren el
      -- | n == "pub-date" = do
      --   d <-
      --     map snd <$>
      --     mapM
      --       convertInlineChildren
      --       (findChildren (QName "day" Nothing Nothing) el)
      --   m <-
      --     map snd <$>
      --     mapM
      --       convertInlineChildren
      --       (findChildren (QName "month" Nothing Nothing) el)
      --   y <-
      --     map snd <$>
      --     mapM
      --       convertInlineChildren
      --       (findChildren (QName "year" Nothing Nothing) el)
      --   addHead $
      --     date $ do
      --       sequence_ m
      --       fromString "/"
      --       sequence_ d
      --       fromString "/"
      --       sequence_ y
      -- | n == "kwd" = do
      --   (_, inline) <- convertInlineChildren el
      --   add $ textit (sequence_ inline)
      -- | n == "b" || n == "bold" = do
      --   (h, i) <- convertInlineChildren el
      --   add (sequence_ h)
      --   add $ textbf (sequence_ i)
      -- | n == "p" = do
      --   let align = lookupAttr' "align"
      --   (h, inline) <- convertInlineChildren el
      --   add $ do
      --     let ma :: Maybe Text
      --         ma =
      --           case fromMaybe "justify" align of
      --             "center" -> Just "Center"
      --             "left" -> Just "FlushLeft"
      --             "right" -> Just "FlushRight"
      --             _ -> Nothing
      --     case ma of
      --       Just a -> begin a (sequence_ (h <> inline))
      --       _ -> sequence_ (h <> inline)
      -- | n == "break" = add newline
      -- | n == "code" || n == "codebold" = do
      --   (h, inline) <- convertInlineChildren el
      --   add $ sequence_ h <> texttt (sequence_ inline)
      -- | n == "?xml" = return ()
      -- | "?" `isPrefixOf` n = return ()
      -- | otherwise =
     =
      case elContent of
        [] -> return ()
        _ ->
            -- liftIO $ hPutStrLn stderr ("[warning] Ignoring tag " <> n)
            convertChildren el

removeSpecial :: String -> String
removeSpecial =
  map
    (\c ->
       if c == ':'
         then '-'
         else c)

convertInlineNode
  :: (MonadState TexState m, MonadIO m) =>
     Content -> m ([LaTeXT Identity ()], [LaTeXT Identity ()])
convertInlineNode c
    | traceShow ("convertInlineNode", c) True = do
    -- = do
  st <- get
  (newState, _) <-
    runTexWriter (st {tsHeadRev = mempty, tsBodyRev = mempty}) (convertNode c)
  return (tsHead newState, tsBody newState)

convertInlineChildren :: MonadTex m => Element -> m ([LaTeXT Identity ()], [LaTeXT Identity ()])
convertInlineChildren el
    | traceShow "convertInlineChildren" True = do
  st <- get
  (newState, _) <-
    runTexWriter (st {tsHeadRev = mempty, tsBodyRev = mempty}) (convertChildren el)
  return (tsHead newState, tsBody newState)

convertChildren :: MonadTex m => Element -> m ()
convertChildren Element{elContent}
    | traceShow "convertChildren" True = do
    -- =
        mapM_ convertNode elContent

comm2
  :: LaTeXC l
  => String -> l -> l -> l
comm2 str = liftL2 $ \l1 l2 -> TeXComm str [FixArg l1, FixArg l2]

begin
  :: Monad m
  => Text -> LaTeXT m () -> LaTeXT m ()
begin n c = between c (raw ("\\begin{" <> n <> "}")) (raw ("\\end{" <> n <> "}"))
