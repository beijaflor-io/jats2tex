# jats2tex
[![Build Status](https://travis-ci.org/beijaflor-io/jats2tex.svg?branch=master)](https://travis-ci.org/beijaflor-io/jats2tex)
[![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/dgixgy1ep3fp9mlq?svg=true)](https://ci.appveyor.com/project/yamadapc/jats2tex)
- - -
**jats2tex** converte JATS-XML para LaTeX.

![](/04.jpg)

## Instalação
### A partir do código fonte
- [Instale o gerenciador de pacotes Haskell `stack`](https://docs.haskellstack.org/en/stable/README/#how-to-install)
- Instale as bibliotecas nativas `expat`, `icu`, `gpm` e `stdc++` usando o
  gerenciador de pacotes do seu sistema
- `git clone https://github.com/beijaflor-io/jats2tex`
- `cd jats2tex`
- `git submodule update --init --recursive`
- Execute `stack install --install-ghc`

### De um pacote binário
- https://github.com/beijaflor-io/jats2tex/releases/

#### Instalador Debian
- https://github.com/beijaflor-io/jats2tex/releases/

#### Instalador Windows
- https://github.com/beijaflor-io/jats2tex/releases/

### Imagem Docker para versão web
Ver https://hub.docker.com/r/beijaflorio/jats2tex/
```
docker run -it beijaflorio/jats2tex \
  -e AWS_ACCESS_KEY_ID="" \                      # Chaves no AWS para envio de e-mails pelo SES
  -e AWS_DEFAULT_REGION="" \
  -e AWS_SECRET_ACCESS_KEY="" \
  -e HOST="*4" \                                 # O host para escutar por conexões
  -e PGDATABASE="" \                             # Nome do banco de dados PostgreSQL
  -e PGHOST="" \                                 # Host do banco de dados PostgreSQL
  -e PGPASS="" \                                 # Senha do banco de dados PostgreSQL
  -e PGUSER="" \                                 # Usuário do banco de dados PostgreSQL
  -e STATIC_DIR="/usr/local/var/jats2tex/static" # Onde estão os arquivos estáticos (na imagem estão nesse local)
```

## Uso básico, convertendo JATS-XML para LaTeX
![](/docs/gifs/jats2tex-uso-basico.gif)

## Comando `jats2tex`
```
jats2tex - Customizable JATS to LaTeX Conversion

Usage: jats2tex (version | upgrade | [-o|--output OUTPUT_FILE]
                [-t|--template TEMPLATE_FILE] [-w|--max-width MAX_COLUMN_WIDTH]
                [-W|--warnings] INPUT_FILE)
  Convert JATS-XML INPUT_FILE to LaTeX OUTPUT_FILE

Available options:
  -o,--output OUTPUT_FILE  LaTeX Output File
  -t,--template TEMPLATE_FILE
                           YAML/JSON Template File
  -w,--max-width MAX_COLUMN_WIDTH
                           Maximum Column Width 80 by default, set to 0 to
                           disable
  -W,--warnings            Enable warnings
  INPUT_FILE               XML Input File
  -h,--help                Show this help text

Available commands:
  version                  Print the version
  upgrade                  Upgrade jats2tex

```

### Exemplos
**Converter arquivo teste.xml e imprimir resultado no terminal**
```
jats2tex ./teste.xml
```

**Converter arquivo teste.xml e imprimir resultado em teste.tex**
```
jats2tex ./teste.xml --output ./teste.tex
```

**Limitar o número de colunas em 100 caracteres**
```
jats2tex ./teste.xml --max-width 100
```

**Desativar "text wrapping"**
```
jats2tex ./teste.xml --max-width 0
```

## Customizando a saída
Para controlar o formato da saída, usamos um arquivo em formato YAML descrevendo
o mapa de tags para TeX.

**O template é especificado para o comando usando a flag `-t`:**
```
jats2tex ./teste.xml -t ./meu-template.yaml
```

O arquivo mapeia `{nome-da-tag}: "\latexcorrespondente"` e permite a
interpolação de _variáveis de contexto_ e _expressões de Haskell_ para a
conversão de nódulos XML para LaTeX.

### Sintaxe
#### Variáveis de contexto disponíveis
- `@@children` Interpola todos os filhos da tag atual convertidos como LaTeX
- `@@heads` Interpola todos os filhos da tag atual marcados como 'head'
- `@@bodies` Interpola todos os filhos da tag atual marcados como 'body'

#### Definindo tags
Definimos tags com:
```yaml
conteudoxml: |
  \conteudolatex{@@children e outras varíaveis ou interpolações}

# ou

conteudoxml-com-head:
  # Conteúdo '@@bodies' dessa correspondência
  # (equivale a `conteudoxml-com-head: "\asdfasdf{}"`)
  body: |
    \asdfadsf{}
  # Conteúdo '@@heads' dessa correspondência
  head: |
    \conteudolatex{@@children e outras varíaveis ou interpolações}
```

##### Exemplo 1: Mapa simples de tag para saída
O template `default.yaml` incluso no `jats2tex` define o seguinte mapa para a
tag `b`, que indica texto em negrito:

```yaml
b: |
  \textbf{@@children}
```

Dado esse template e um arquivo XML como:
```xml
<b>Olá mundo</b>
```

O programa irá produzir:
```latex
% Generated by jats2tex@x.x.x.x
\textbf{Olá mundo}
```

##### Exemplo 2: Usando `@@heads` e `@@bodies` para controlar a estrutura da saída
Dado um XML:
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<front>
  <article-meta>
    <title-group>
      <article-title xml:lang="en">My Title</article-title>
    </title-group>
  </article-meta>
</front>
<body>Meu texto aqui</body>
</article>
```

Queremos a saída:
```tex
\documentclass{article}
\begin{document}
\title{My Title}
\maketitle
Meu texto aqui
\end{document}
```

Para isso podemos usaríamos o template:
```yaml
article:
  head: |
    \documentclass{article}
    \begin{document}
    @@heads
    \maketitle
    @@bodies
    \end{document}

article-title:
  head: |
    \title{@@children}
```
Como `article-title` tem sua saída marcada como `head`, seu conteúdo é
interpolado como `@@heads`, enquanto o corpo do texto por padrão simplesmente é
interpolado como visto, se não estiver mapeado por `@@bodies`.

#### Interpolação de Lua/Haskell
Além das diretrizes acima, o `jats2tex` incluí em seus templates suporte para a
interpolação de expressões arbitrárias nas linguagens de programação Haskell e
Lua, que são executadas em runtime.

##### Interpolando Haskell
A sintaxe é:
```yaml
p: |
  \saida{@@(
    findChildren "font"
  )@@}
```

##### Interpolando Lua
A sintaxe é:
```yaml
p: |
  \saida{@@lua(
    return find("font")
  )@@}
```
Os helpers disponíveis são:

- `children()` Retorna os filhos do elemento atual como texto
- `attr(<attr>)` Retorna o valor do atributo `attr` no elemento atual como texto
- `find(<tag>)` Encontra os filhos do elemento atual que sejam instâncias da tag
  `tag` e os retorna como texto
- `elements()` Encontra apenas os filhos do elemento atual que sejam elementos
  XML ignorando qualquer texto, quebras de linha e espaços nos filhos diretos do
  elemento atual

##### Exemplo 3: Intercalando "\and" entre os autores de um artigo (Lua)
Template:
```yaml
name: |
  @@lua(
  s = find "surname"
  g = find "given-names"
  return s .. ", " .. g
  )@@

contrib-group:
  head: |

    \author{@@lua(
    return table.concat(elements(), '\\and ')
    )@@}
```

Entrada:
```xml
<contrib-group>
  <contrib contrib-type="author">
    <name>
      <surname><![CDATA[Quiroga Selez]]></surname>
      <given-names><![CDATA[Gabriela]]></given-names>
    </name>
  </contrib>
  <contrib contrib-type="author">
    <name>
      <surname><![CDATA[Giménez Turba]]></surname>
      <given-names><![CDATA[Alberto]]></given-names>
    </name>
  </contrib>
</contrib-group>
```

Saída:
```latex
\author{Quiroga Selez, Gabriela
\and Giménez Turba, Alberto
}
```

### Man Pages
![](/docs/gifs/jats2tex-man-pages.gif)

## Comando `jats2tex-web`
![](/docs/gifs/jats2tex-web.gif)

- - -

## Formato dos templates
Em aberto, os templates usados pelo Jats2tex terão um formato de fácil escrita por
humanos e computadores, um mapa de chaves e valores com suporte a nesting
(por exemplo, `conf`, `yml`, `json`, `ini`).

## Implementação
A partir do formato do template com suporte a customização da renderização de
elementos e atributos em contextos diferentes, um tipo intermediário e um
renderizador estilo "Visitor", o programa lerá e executará um parser XML no
input, conseguindo um tipo 'Artigo' - ou falhando com entrada inválida.

O programa usa o template para configurar um renderizador desse tipo para
LaTeX, usando uma linguagem monádica exposta pelo pacote `HaTeX`.

## Tecnologia
A tecnologia usada para elaborar a solução será a linguagem de programação
Haskell e pacotes embutidos para:

- A construção de parsers
- Parsing de arquivos XML
- Renderização de LaTeX/ConText válido

## Metodologia
O trabalho será feito usando a metodologia Agile de desenvolvimento de
Software. Assim o trabalho será dividido em metas curtas (Sprints) com o
período de uma semana.

O projeto será disponibilizado online via GitHub, escrito usando código
aberto. Ao final de cada semana, uma versão será empacotada e publicada com as
melhorias executadas.

## Interfaces de Uso
### Web
Um endpoint `POST` receberá dados em formato JATS-XML e dará o texto convertido
para LaTeX como resposta. Opcionalmente, recebe também o arquivo/texto de um
template.

### CLI
Opções serão expostas pela linha de comando usando o `optparse-applicative`, o
comando recebe um template e uma entrada JATS-XML e escreve o resultado para a
saída padrão.
